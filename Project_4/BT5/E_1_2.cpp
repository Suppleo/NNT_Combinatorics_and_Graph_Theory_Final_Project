#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <unordered_map>
#include <cassert>
#include <algorithm>

using namespace std;

struct Edge {
    int src;
    int tgt;
    int label;
};

class SGBGraph {
public:
    vector<string> vertices;         // Vertex labels
    vector<Edge> edges;              // List of edges (src, tgt, label)

    void read_sgb(const string& filename) {
        ifstream file(filename);
        if (!file) {
            cerr << "Failed to open file." << endl;
            return;
        }

        vector<string> lines;
        string line;
        while (getline(file, line)) {
            if (!line.empty()) {
                lines.push_back(line);
            }
        }

        assert(lines[0].rfind("* GraphBase", 0) == 0);

        int v_start = -1, a_start = -1, checksum_idx = -1;
        for (int i = 0; i < lines.size(); ++i) {
            if (lines[i] == "* Vertices") v_start = i + 1;
            else if (lines[i] == "* Arcs") a_start = i + 1;
            else if (lines[i].rfind("* Checksum", 0) == 0) checksum_idx = i;
        }

        assert(v_start != -1 && a_start != -1 && checksum_idx != -1);

        vertices.clear();
        vector<int> vertex_edges;

        for (int i = v_start; i < a_start - 1; ++i) {
            stringstream ss(lines[i]);
            string label;
            int Ai;
            getline(ss, label, ',');
            ss >> Ai;
            vertices.push_back(label);
            vertex_edges.push_back(Ai);
        }

        vector<int> edge_targets, edge_nexts, edge_labels;

        for (int i = a_start; i < checksum_idx; ++i) {
            stringstream ss(lines[i]);
            string tmp;
            int tgt, Ai, label;
            ss >> tmp >> tgt; // read "V j"
            ss.ignore(); // skip comma
            ss >> Ai;
            ss.ignore();
            ss >> label;
            edge_targets.push_back(tgt);
            edge_nexts.push_back(Ai);
            edge_labels.push_back(label);
        }

        unordered_map<int, tuple<int, int, int>> edge_map;
        for (int i = 0; i < edge_targets.size(); ++i) {
            edge_map[i + 1] = make_tuple(edge_targets[i], edge_nexts[i], edge_labels[i]);
        }

        edges.clear();
        for (int v = 0; v < vertex_edges.size(); ++v) {
            int i = vertex_edges[v];
            while (i != 0) {
                auto [tgt, nxt, lbl] = edge_map[i];
                edges.push_back({v, tgt, lbl});
                i = nxt;
            }
        }
    }

    void write_sgb(const string& filename) {
        ofstream file(filename);
        int n = vertices.size();
        int m = edges.size();

        file << "* GraphBase graph (utiltypes ...," << n << "," << m << ")\n";
        file << "Generated by SGBGraph\n";
        file << "* Vertices\n";

        int edge_idx = 1;
        unordered_map<int, tuple<int, int, int>> edge_chain;
        unordered_map<int, int> vertex_first_edge;

        for (int v = 0; v < n; ++v) {
            vector<pair<int, Edge>> out_edges;
            for (int i = 0; i < edges.size(); ++i) {
                if (edges[i].src == v) {
                    out_edges.emplace_back(i, edges[i]);
                }
            }

            if (out_edges.empty()) {
                vertex_first_edge[v] = 0;
                continue;
            }

            int first_i = edge_idx;
            vertex_first_edge[v] = first_i;

            for (int i = 0; i < out_edges.size(); ++i) {
                int curr_id = edge_idx++;
                int next_id = (i < out_edges.size() - 1) ? edge_idx : 0;
                Edge& e = out_edges[i].second;
                edge_chain[curr_id] = make_tuple(e.tgt, next_id, e.label);
            }
        }

        for (int v = 0; v < n; ++v) {
            file << vertices[v] << "," << vertex_first_edge[v] << ",0,0\n";
        }

        file << "* Arcs\n";
        for (const auto& [i, tup] : edge_chain) {
            auto [tgt, nxt, lbl] = tup;
            file << "V " << tgt << "," << nxt << "," << lbl << ",0\n";
        }

        file << "* Checksum 0\n";
    }
};
